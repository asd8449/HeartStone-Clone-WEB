<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>덱 만들기 - {{hero.name}}</title>
<style>
    body { font-family: sans-serif; display: flex; gap: 20px; padding: 10px; background-color: #f0e6d2; }
    .main-container { flex-grow: 1; color: #333; }
    .deck-container { width: 320px; padding: 10px; background: #fff; border: 1px solid #ccc; border-radius: 8px; color: #333; display: flex; flex-direction: column; }
    .card-list { display: flex; flex-wrap: wrap; gap: 10px; list-style: none; padding: 0; overflow-y: auto; max-height: 80vh; }
    .card { border: 2px solid #333; border-radius: 10px; padding: 5px; width: 120px; height: 170px; cursor: pointer; background-color: #eaeaea; display: flex; flex-direction: column; justify-content: space-between; position: relative; }
    .card:hover { border-color: gold; box-shadow: 0 0 10px gold; }
    .card-cost { position: absolute; top: -5px; left: -5px; background: #007bff; color: white; width: 24px; height: 24px; border-radius: 50%; display:flex; align-items:center; justify-content: center; font-weight: bold; font-size: 1.1em; border: 2px solid white; }
    .card-name { font-weight: bold; margin-top: 5px; font-size: 0.9em; text-align: center; }
    .card-stats { display: flex; justify-content: space-between; font-weight: bold; font-size: 1.2em; padding: 0 5px; margin-bottom: 5px; }
    .deck-card-list-container { flex-grow: 1; overflow-y: auto; }
    .deck-card-list { list-style: none; padding: 0; margin: 0; }
    .deck-card-item { display: flex; align-items: center; padding: 4px; border-bottom: 1px solid #eee; cursor: pointer; position: relative; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .deck-card-item:hover { background-color: #f5f5f5; }
    .deck-card-tile { width: 140px; height: 34px; background-size: cover; background-position: center; border-radius: 4px; margin-right: 10px; flex-shrink: 0; }
    .deck-card-cost { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); font-size: 1.2em; font-weight: bold; color: white; text-shadow: 1px 1px 2px black, 0 0 5px black; }
    .deck-card-name { flex-grow: 1; font-weight: 500; overflow: hidden; text-overflow: ellipsis; }
    .deck-card-quantity { font-weight: bold; font-size: 1em; margin-left: 5px; color: #555; }
    .deck-info { margin-bottom: 15px; }
    .deck-info input { width: calc(100% - 10px); padding: 5px; }
    .cost-filter button { margin: 2px; }
    .cost-filter .active { background-color: #007bff; color: white; }
    .disabled { opacity: 0.5; cursor: not-allowed; border-color: #999 !important; }
</style>
</head>
<body>

    <div class="deck-container">
        <h2>{{hero.name}} 덱</h2>
        <div class="deck-info">
            <input type="text" id="deckName" placeholder="덱 이름을 입력하세요" value="{{hero.className}} 덱" maxlength="50">
            <h3>덱 (<span id="deckCount">0</span>/30)</h3>
            <button id="saveDeckBtn" disabled>덱 저장</button>
            <a href="/deck" style="margin-left: 10px;">목록으로</a>
        </div>
        <div class="deck-card-list-container">
             <ul id="deckCardList"></ul>
        </div>
    </div>

    <div class="main-container">
        <h1>카드 목록 (클릭하여 덱에 추가)</h1>
        <div class="cost-filter">
            <strong>비용:</strong>
            <button data-cost="-1" class="active">전체</button>
            <button data-cost="0">0</button>
            <button data-cost="1">1</button>
            <button data-cost="2">2</button>
            <button data-cost="3">3</button>
            <button data-cost="4">4</button>
            <button data-cost="5">5</button>
            <button data-cost="6">6</button>
            <button data-cost="7">7+</button>
        </div>
        <hr>
        <div class="card-list" id="allCardList">
            {{#allCards}}
            <li class="card" 
                data-card-no="{{no}}" 
                data-card-id="{{cardId}}"
                data-card-name="{{name}}" 
                data-card-cost="{{cost}}"
                data-attack="{{attack}}" 
                data-health="{{health}}"
                onclick="addCardToDeck(this)">
                <div class="card-cost">{{cost}}</div>
                <div class="card-name">{{name}}</div>
                <div class="card-stats">
                    <span class="card-attack">{{attack}}</span>
                    <span class="card-health">{{health}}</span>
                </div>
            </li>
            {{/allCards}}
        </div>
    </div>

<script>
    const deck = new Map();
    const deckLimit = 30;
    
    const deckCountEl = document.getElementById('deckCount');
    const deckCardListEl = document.getElementById('deckCardList');
    const saveDeckBtn = document.getElementById('saveDeckBtn');

    function addCardToDeck(cardElement) {
        const cardNo = parseInt(cardElement.dataset.cardNo);
        const cardId = cardElement.dataset.cardId;
        const cardName = cardElement.dataset.cardName;
        const cardCost = parseInt(cardElement.dataset.cardCost);
        
        const currentDeckSize = Array.from(deck.values()).reduce((sum, card) => sum + card.quantity, 0);

        if (currentDeckSize >= deckLimit) {
            alert("덱은 30장까지 구성할 수 있습니다.");
            return;
        }

        if (deck.has(cardNo)) {
            if (deck.get(cardNo).quantity >= 2) {
                alert("같은 카드는 2장까지만 넣을 수 있습니다.");
                return;
            }
            deck.get(cardNo).quantity++;
        } else {
            deck.set(cardNo, { id: cardId, name: cardName, cost: cardCost, quantity: 1 });
        }
        renderDeck();
    }
    
    function removeCardFromDeck(cardNo) {
        if (!deck.has(cardNo)) return;
        deck.get(cardNo).quantity--;
        if (deck.get(cardNo).quantity === 0) {
            deck.delete(cardNo);
        }
        renderDeck();
    }

    function renderDeck() {
        deckCardListEl.innerHTML = '';
        const currentDeckSize = Array.from(deck.values()).reduce((sum, card) => sum + card.quantity, 0);
        deckCountEl.textContent = currentDeckSize;
        saveDeckBtn.disabled = (currentDeckSize !== deckLimit);

        const sortedDeck = new Map([...deck.entries()].sort((a, b) => {
            const cardA = a[1];
            const cardB = b[1];
            if (cardA.cost !== cardB.cost) return cardA.cost - b[1].cost;
            return cardA.name.localeCompare(b.name);
        }));

        for (const [no, card] of sortedDeck) {
            const imageUrl = `https://art.hearthstonejson.com/v1/tiles/${card.id}.jpg`;
            const li = document.createElement('li');
            li.className = 'deck-card-item';
            li.onclick = () => removeCardFromDeck(no);
            
            li.innerHTML = `
                <div class="deck-card-tile" style="background-image: url('${imageUrl}')">
                    <span class="deck-card-cost">${card.cost}</span>
                </div>
                <span class="deck-card-name">${card.name}</span>
                <span class="deck-card-quantity">x${card.quantity}</span>
            `;
            deckCardListEl.appendChild(li);
        }
        updateAllCardListAvailability();
    }

    function updateAllCardListAvailability() {
        const currentDeckSize = Array.from(deck.values()).reduce((sum, card) => sum + card.quantity, 0);
        document.querySelectorAll('#allCardList .card').forEach(cardEl => {
            const cardNo = parseInt(cardEl.dataset.cardNo);
            let isDisabled = false;
            if (currentDeckSize >= deckLimit) {
                isDisabled = true;
            } else if (deck.has(cardNo) && deck.get(cardNo).quantity >= 2) {
                isDisabled = true;
            }
            cardEl.classList.toggle('disabled', isDisabled);
            cardEl.onclick = isDisabled ? null : () => addCardToDeck(cardEl);
        });
    }
    
    document.querySelectorAll('.cost-filter button').forEach(button => {
        button.addEventListener('click', function() {
            document.querySelector('.cost-filter .active').classList.remove('active');
            this.classList.add('active');
            const filterCost = parseInt(this.dataset.cost);
            document.querySelectorAll('#allCardList .card').forEach(cardEl => {
                const cardCost = parseInt(cardEl.dataset.cardCost);
                let shouldShow = (filterCost === -1) || (filterCost === 7 && cardCost >= 7) || (cardCost === filterCost);
                cardEl.style.display = shouldShow ? 'flex' : 'none';
            });
        });
    });

    saveDeckBtn.addEventListener('click', async function() {
        const deckName = document.getElementById('deckName').value;
        if (!deckName) {
            alert('덱 이름을 입력해주세요.');
            return;
        }
        const cardIds = [];
        for (const [no, card] of deck) {
            for (let i = 0; i < card.quantity; i++) {
                cardIds.push(no);
            }
        }
        const data = { deckName: deckName, cardIds: cardIds };
        
        try {
            const response = await fetch(`/deck/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            const result = await response.json();
            if (response.ok) {
                alert(result.message);
                window.location.href = '/deck';
            } else {
                alert('덱 저장 실패: ' + (result.body || result.message));
            }
        } catch (error) {
            alert('덱 저장 중 오류가 발생했습니다.');
        }
    });
</script>

</body>
</html>